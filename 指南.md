这是一个详细的 `DobotDllType.py` 使用指南，旨在帮助你深入理解并开发自己的 Dobot 控制程序。该模块是 Dobot 动态链接库（DLL）的 Python 封装，掌握它就掌握了控制机械臂的核心。

---

# DobotDllType 使用指南

## 1. 核心概念

在开始编程前，必须理解以下两个核心机制，这是避免“代码没报错但机器不动”的关键。

### 1.1 `isQueued` 参数（立即执行 vs 队列执行）
几乎所有的运动和设置函数（如 `SetPTPCmd`, `SetEndEffectorSuctionCup`）都有一个 `isQueued` 参数：
*   **`isQueued=0` (默认)**：**立即指令**。指令发送后立即执行，不进入队列。通常用于状态查询或急停。
*   **`isQueued=1`**：**队列指令**。指令会被加入到底层的命令缓冲区，等待控制器按顺序调度。**推荐在自动化脚本中主要使用此模式**。

### 1.2 指令队列控制
如果你使用了 `isQueued=1`，必须配合以下指令机器才会动：
*   `dType.SetQueuedCmdClear(api)`: 清空旧指令。
*   `dType.SetQueuedCmdStartExec(api)`: **开始执行队列**。如果不调用这句，队列里的指令会一直堆积但不执行。
*   `dType.GetQueuedCmdCurrentIndex(api)`: 获取当前正在执行的指令索引，常用于判断“动作是否完成”。

---

## 2. 基础流程 API

这是任何程序都必须包含的生命周期代码。

### 2.1 加载与连接
```python
import DobotDllType as dType

# 1. 加载 DLL
api = dType.load()

# 2. 连接机械臂
# portName: 串口号 (Windows下留空""通常能自动扫描，或者指定 "COM3")
# baudrate: 波特率，固定 115200
# 返回值 state: 0 (NoError), 1 (NotFound), 2 (Occupied)
state = dType.ConnectDobot(api, "", 115200)[0]

if state == dType.DobotConnect.DobotConnect_NoError:
    print("连接成功")
    # 建议连接后立即清空队列并设置超时
    dType.SetQueuedCmdClear(api)
    dType.SetCmdTimeout(api, 3000)
else:
    print("连接失败")
```

### 2.2 断开连接
```python
dType.DisconnectDobot(api)
```

---

## 3. 运动控制 API (最重要)

### 3.1 回零 (Homing)
在每次开机后，建议执行一次回零以校准坐标。
```python
# temp参数预留，填0
# 返回值 last_index: 该指令在队列中的索引 ID
last_index = dType.SetHOMECmd(api, temp=0, isQueued=1)[0]
```

### 3.2 点到点运动 (PTP - Point to Point)
这是最常用的移动方式。
*   **函数**: `SetPTPCmd(api, ptpMode, x, y, z, rHead, isQueued)`
*   **参数**:
    *   `ptpMode`: 运动模式 (见下表)
    *   `x, y, z`: 目标坐标 (mm)
    *   `rHead`: 末端旋转轴角度 (度)

| PTPMode 常量 | 含义 | 描述 |
| :--- | :--- | :--- |
| `PTPJUMPXYZMode` | 门型跳跃 | 抬起 -> 平移 -> 落下 (最常用，避障) |
| `PTPMOVJXYZMode` | 关节插补 | 路径不一定是直线，速度快 |
| `PTPMOVLXYZMode` | 直线插补 | 路径是严格直线 |
| `PTPMOVJXYZINCMode` | 相对坐标(关节) | 基于当前位置的增量移动 (例如 x+10) |

**代码示例**:
```python
# 移动到绝对坐标 (200, 0, 0)，R轴0度
dType.SetPTPCmd(api, dType.PTPMode.PTPMOVLXYZMode, 200, 0, 0, 0, isQueued=1)

# 相对当前位置，Z轴向上抬升 50mm
dType.SetPTPCmd(api, dType.PTPMode.PTPMOVJXYZINCMode, 0, 0, 50, 0, isQueued=1)
```

### 3.3 点动控制 (JOG)
用于手动控制或持续运动（按下按钮走，松开停）。
*   **函数**: `SetJOGCmd(api, isJoint, cmd, isQueued)`
*   **参数**:
    *   `isJoint`: 0 (坐标系运动), 1 (关节运动)
    *   `cmd`: 具体动作指令

| cmd 常量 | 对应动作 |
| :--- | :--- |
| `JogIdle` (0) | **停止运动** (非常重要) |
| `JogAPPressed` (1) | X+ / Joint1+ |
| `JogANPressed` (2) | X- / Joint1- |
| `JogBPPressed` (3) | Y+ / Joint2+ |
| ... | Z(C), R(D) 依次类推 |

---

## 4. 状态获取 API

在 `isQueued=0` (立即模式) 下调用，获取机器当前状态。

### 4.1 获取位姿
```python
pose = dType.GetPose(api)
print(f"X:{pose[0]} Y:{pose[1]} Z:{pose[2]} R:{pose[3]}")
print(f"Joint1:{pose[4]} ...")
```

### 4.2 判断动作是否完成 (同步等待)
这是编写自动化脚本时的核心逻辑。
```python
# 1. 发送指令，记录返回的索引 ID
last_index = dType.SetPTPCmd(api, dType.PTPMode.PTPMOVLXYZMode, 200, 0, 0, 0, isQueued=1)[0]

# 2. 循环等待，直到当前执行索引 >= 目标索引
while last_index > dType.GetQueuedCmdCurrentIndex(api)[0]:
    dType.dSleep(100) # 避免死循环占用 CPU
    
print("动作已完成")
```

---

## 5. 末端执行器与 I/O API

### 5.1 吸盘 (Suction Cup)
```python
# enableCtrl: 1(启用控制)
# on: 1(吸气/吸住), 0(排气/释放)
dType.SetEndEffectorSuctionCup(api, enableCtrl=1, on=1, isQueued=1)
```

### 5.2 夹爪 (Gripper)
```python
# enableCtrl: 1(启用)
# on: 1(闭合/抓取), 0(张开/松开)
dType.SetEndEffectorGripper(api, enableCtrl=1, on=1, isQueued=1)
```

### 5.3 激光/PWM (Laser)
```python
# enableCtrl: 1(启用)
# on: 1(开启激光)
dType.SetEndEffectorLaser(api, enableCtrl=1, on=1, isQueued=1)
```

### 5.4 通用 I/O (EIO)
Magician 背后的接口（GP1, GP2, ...）可以通过以下函数控制。
*   `SetIOMultiplexing`: 设置引脚复用功能（是做PWM，还是做普通IO）。
*   `SetIODO`: 设置数字输出高低电平 (5V/3.3V)。
*   `GetIODI`: 读取输入电平。

---

## 6. 开发实战模板

你可以直接复制这个模板开始开发：

```python
import threading
import DobotDllType as dType
import time

# 加载接口
api = dType.load()

# 连接设备
state = dType.ConnectDobot(api, "", 115200)[0]

if (state == dType.DobotConnect.DobotConnect_NoError):
    print("连接成功！")

    # --- 初始化 ---
    dType.SetQueuedCmdClear(api) # 清空队列
    
    # 设置运动参数 (速度/加速度百分比)
    dType.SetPTPCommonParams(api, velocityRatio=50, accelerationRatio=50, isQueued=1)
    
    # --- 任务流程 ---
    
    # 1. 回零
    print("正在回零...")
    last_index = dType.SetHOMECmd(api, temp=0, isQueued=1)[0]
    dType.SetQueuedCmdStartExec(api) # 开启队列执行
    
    # 等待回零结束
    while last_index > dType.GetQueuedCmdCurrentIndex(api)[0]:
        dType.dSleep(100)
    print("回零完成")

    # 2. 移动到点 A (抓取点)
    dType.SetPTPCmd(api, dType.PTPMode.PTPJUMPXYZMode, 200, 50, 0, 0, isQueued=1)
    
    # 3. 开启吸盘
    dType.SetEndEffectorSuctionCup(api, 1, 1, isQueued=1)
    
    # 4. 延时 500ms 等待吸稳
    dType.SetWAITCmd(api, 500, isQueued=1)
    
    # 5. 移动到点 B (放置点)
    last_index = dType.SetPTPCmd(api, dType.PTPMode.PTPJUMPXYZMode, 200, -50, 0, 0, isQueued=1)[0]
    
    # 6. 等待上述动作全部完成
    while last_index > dType.GetQueuedCmdCurrentIndex(api)[0]:
        dType.dSleep(100)
        
    # 7. 松开吸盘
    dType.SetEndEffectorSuctionCup(api, 1, 0, isQueued=1)
    
    print("任务结束")

    # --- 清理 ---
    dType.SetQueuedCmdStopExec(api)
    dType.DisconnectDobot(api)

else:
    print("连接失败，请检查USB连接")
```